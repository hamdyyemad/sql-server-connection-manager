import {
  User,
  UserRepository,
  UserProjection,
  LoginProjection,
  Setup2FAProjection,
  Verify2FAProjection,
  UserStatusProjection,
} from "@/backend_lib/types/auth";
import { hashPassword, verifyPassword } from "@/backend_lib/utils";

export class UserService {
  constructor(private userRepo: UserRepository) {}

  // Create a new user with proper validation
  async createUser(userData: {
    username: string;
    password: string;
    hasSetup2FA?: boolean;
    secret2FA?: string;
    tempSecret2FA?: string;
    isActive?: boolean;
  }): Promise<User> {
    const {
      username,
      password,
      hasSetup2FA = false,
      secret2FA = undefined,
      tempSecret2FA = undefined,
      isActive = true,
    } = userData;

    // Validate user data
    await this.validateUserCreation(userData);

    // Generate password hash
    const passwordHash = await hashPassword(password);

    // Create user (repository will auto-generate id, createdAt, updatedAt)
    // create(user: Omit<User, "id" | "createdAt" | "updatedAt">): Promise<User>
    const user = await this.userRepo.create({
      username,
      passwordHash,
      passwordSalt: "", // Will be generated by repository
      hasSetup2FA,
      is2FAVerified: false,
      is2FAEnabled: true,
      secret2FA,
      tempSecret2FA,
      isActive,
    });

    return user;
  }

  // Create admin user with default settings
  async createAdminUser(username: string, password: string): Promise<User> {
    // Use the same validation and creation logic as createUser
    return await this.createUser({
      username,
      password,
      hasSetup2FA: false,
      secret2FA: undefined,
      tempSecret2FA: undefined,
      isActive: true,
    });
  }

  // Verify user credentials
  async verifyCredentials(
    username: string,
    password: string
  ): Promise<{
    isValid: boolean;
    user: User | null;
  }> {
    try {
      const user = await this.userRepo.findByUsername(username);

      if (!user) {
        return { isValid: false, user: null };
      }

      const isValidPassword = await verifyPassword(password, user.passwordHash);

      return {
        isValid: isValidPassword,
        user: isValidPassword ? user : null,
      };
    } catch (error) {
      throw new Error(
        `Failed to verify credentials: ${
          error instanceof Error ? error.message : "Unknown error"
        }`
      );
    }
  }

  // Verify password against existing user object (optimized)
  async verifyPasswordForUser(user: User, password: string): Promise<boolean> {
    return await verifyPassword(password, user.passwordHash);
  }

  // Verify password for login projection (optimized for login strategy)
  async verifyPasswordForLoginProjection(
    user: LoginProjection,
    password: string
  ): Promise<boolean> {
    return await verifyPassword(password, user.passwordHash);
  }

  // Get user by username
  async getUserByUsername(username: string): Promise<User | null> {
    return await this.userRepo.findByUsername(username);
  }

  // Get user by username with projection for better performance
  async getUserByUsernameWithProjection<T extends Partial<User>>(
    username: string,
    projection: UserProjection
  ): Promise<T | null> {
    return await this.userRepo.findByUsernameWithProjection<T>(
      username,
      projection
    );
  }

  // Get user by ID
  async getUserById(userId: string): Promise<User | null> {
    return await this.userRepo.findById(userId);
  }

  // Get user by ID with projection for better performance
  async getUserByIdWithProjection<T extends Partial<User>>(
    userId: string,
    projection: UserProjection
  ): Promise<T | null> {
    return await this.userRepo.findByIdWithProjection<T>(userId, projection);
  }

  // Strategy-specific methods for optimal performance

  // Get user for login strategy (only needed fields)
  async getUserForLogin(username: string): Promise<LoginProjection | null> {
    return await this.userRepo.findByUsernameWithProjection<LoginProjection>(
      username,
      ["id", "username", "passwordHash", "hasSetup2FA", "is2FAEnabled"]
    );
  }

  // Get user for 2FA setup strategy (only needed fields)
  async getUserForSetup2FA(userId: string): Promise<Setup2FAProjection | null> {
    return await this.userRepo.findByIdWithProjection<Setup2FAProjection>(
      userId,
      ["id", "username", "hasSetup2FA", "secret2FA"]
    );
  }

  // Get user for 2FA verification strategy (only needed fields)
  async getUserForVerify2FA(
    userId: string
  ): Promise<Verify2FAProjection | null> {
    return await this.userRepo.findByIdWithProjection<Verify2FAProjection>(
      userId,
      ["id", "username", "secret2FA", "tempSecret2FA"]
    );
  }

  // Get user status for determining next step (only needed fields)
  async getUserStatus(userId: string): Promise<UserStatusProjection | null> {
    return await this.userRepo.findByIdWithProjection<UserStatusProjection>(
      userId,
      ["id", "hasSetup2FA", "is2FAEnabled"]
    );
  }

  // Update user
  async updateUser(userId: string, updates: Partial<User>): Promise<User> {
    return await this.userRepo.update(userId, updates);
  }

  // Delete user
  async deleteUser(userId: string): Promise<void> {
    return await this.userRepo.delete(userId);
  }

  // Change user password
  async changePassword(userId: string, newPassword: string): Promise<void> {
    const passwordHash = await hashPassword(newPassword);

    await this.userRepo.update(userId, {
      passwordHash,
    });
  }

  // Update user's last login time
  async updateLastLogin(userId: string): Promise<void> {
    await this.userRepo.updateLastLogin(userId);
  }

  // Update 2FA secret
  async update2FASecret(userId: string, secret: string): Promise<void> {
    await this.userRepo.update2FASecret(userId, secret);
  }

  // Update 2FA status
  async update2FAStatus(userId: string, hasSetup2FA: boolean): Promise<void> {
    await this.userRepo.update2FAStatus(userId, hasSetup2FA);
  }

  // Update temporary 2FA secret
  async updateTempSecret(userId: string, secret: string): Promise<void> {
    await this.userRepo.updateTempSecret(userId, secret);
  }

  // Update 2FA verification status
  async update2FAVerificationStatus(
    userId: string,
    isVerified: boolean
  ): Promise<void> {
    await this.userRepo.update2FAVerificationStatus(userId, isVerified);
  }

  // Get temporary 2FA secret
  async getTempSecret(userId: string): Promise<string | null> {
    const user = await this.userRepo.findById(userId);
    return user?.tempSecret2FA || null;
  }

  // Complete 2FA setup
  async complete2FASetup(userId: string, secret: string): Promise<void> {
    await this.userRepo.complete2FASetup(userId, secret);
  }

  // Get user statistics
  async getUserStats(): Promise<{
    total: number;
    active: number;
    with2FA: number;
  }> {
    // Since UserRepository doesn't have getAllUsers method, we'll implement a simple version
    // In a real implementation, you'd want to add getAllUsers() to the UserRepository interface

    // For now, return mock data since we can't get all users with current interface
    // TODO: Add getAllUsers() method to UserRepository interface
    return {
      total: 1, // Mock data
      active: 1, // Mock data
      with2FA: 0, // Mock data
    };
  }

  // Validation method for user creation
  private async validateUserCreation(userData: {
    username: string;
    password: string;
    hasSetup2FA?: boolean;
    secret2FA?: string;
    tempSecret2FA?: string;
    isActive?: boolean;
  }): Promise<void> {
    const { username, password } = userData;

    // Validate required fields
    if (!username || !password) {
      throw new Error("Username and password are required");
    }

    // Validate username format (basic validation)
    if (username.length < 3 || username.length > 50) {
      throw new Error("Username must be between 3 and 50 characters");
    }

    // Validate password strength (basic validation)
    if (password.length < 6) {
      throw new Error("Password must be at least 6 characters long");
    }

    // Check if username already exists
    const existingUser = await this.userRepo.findByUsername(username);
    if (existingUser) {
      throw new Error(`User with username '${username}' already exists`);
    }
  }
}
